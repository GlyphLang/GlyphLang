# Intent Test: Authentication service with registration, login, and token management
# NOTE: This is a DSL syntax demonstration for polyglot code generation testing.
# Actual security (bcrypt hashing, JWT signing, HTTPS) is implemented by target
# language backends. Glyph DSL functions like crypto.hash() and jwt.sign() map
# to secure implementations in each target (e.g., bcrypt in Go, passlib in Python).

: User {
  id: str!
  email: str!
  name: str!
  password_hash: str!
  role: str!
  created_at: int!
  last_login: int?
}

: RegisterInput {
  email: str!
  name: str!
  password: str!
}

: LoginInput {
  email: str!
  password: str!
}

: AuthResponse {
  token: str!
  refresh_token: str!
  expires_in: int!
  user: User!
}

: TokenRefreshInput {
  refresh_token: str!
}

# Public: Register a new user
@ POST /auth/register {
  + ratelimit(10/min)
  < input: RegisterInput
  % db: Database

  $ existing = db.users.Where({email: input.email})
  if existing.length() > 0 {
    > {error: "Email already registered"}
  } else {
    # crypto.hash maps to bcrypt/argon2 in target language
    $ hashedPassword = crypto.hash(input.password)

    $ user = db.users.Create({
      id: generateId(),
      email: input.email,
      name: input.name,
      password_hash: hashedPassword,
      role: "user",
      created_at: now()
    })

    # jwt.sign maps to proper JWT library in target language
    $ token = jwt.sign({
      user_id: user.id,
      email: user.email,
      role: user.role
    }, "7d")

    > {
      token: token,
      refresh_token: generateId(),
      expires_in: 3600,
      user: user
    }
  }
}

# Public: Login with email and password
@ POST /auth/login {
  + ratelimit(20/min)
  < input: LoginInput
  % db: Database

  $ users = db.users.Where({email: input.email})
  if users.length() == 0 {
    > {error: "Invalid credentials"}
  } else {
    $ user = users[0]

    # crypto.verify maps to bcrypt.compare in target language
    $ passwordValid = crypto.verify(input.password, user.password_hash)
    if passwordValid == false {
      > {error: "Invalid credentials"}
    } else {
      $ updated = db.users.Update(user.id, {last_login: now()})

      $ token = jwt.sign({
        user_id: user.id,
        email: user.email,
        role: user.role
      }, "7d")

      > {
        token: token,
        refresh_token: generateId(),
        expires_in: 3600,
        user: user
      }
    }
  }
}

# Authenticated: Refresh an access token
@ POST /auth/refresh {
  + auth(jwt)
  < input: TokenRefreshInput
  % db: Database

  $ sessions = db.sessions.Where({refresh_token: input.refresh_token})
  if sessions.length() == 0 {
    > {error: "Invalid refresh token"}
  } else {
    $ first_session = sessions[0]

    $ token = jwt.sign({
      user_id: auth.user.id,
      role: auth.user.role
    }, "7d")

    > {
      token: token,
      refresh_token: generateId(),
      expires_in: 3600,
      user: first_session.user
    }
  }
}

# Authenticated: Get current user profile
@ GET /auth/me {
  + auth(jwt)
  % db: Database
  $ user = db.users.Get(auth.user.id)
  if user == null {
    > {error: "User not found"}
  } else {
    > user
  }
}

# Authenticated: Logout
@ POST /auth/logout {
  + auth(jwt)
  % db: Database
  $ deleted = db.sessions.Delete(auth.user.id)
  > {logged_out: true}
}

# Admin: List all users
@ GET /auth/admin/users {
  + auth(jwt, role: admin)
  + ratelimit(50/min)
  % db: Database
  $ users = db.users.Find()
  > users
}

# Cron: Clean up expired sessions daily
* "0 3 * * *" session_cleanup {
  % db: Database
  $ expired = db.sessions.Where({expired: true})
  > {task: "session_cleanup", timestamp: now()}
}
