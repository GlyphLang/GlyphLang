# GlyphLang Macro Demo
# This example demonstrates compile-time macros and code generation

# Define a logging macro
# When invoked, it generates an if statement that checks the log level
macro! log(level, msg) {
    if config.logLevel >= level {
        $ logEntry = {
            level: level,
            message: msg,
            timestamp: now()
        }
        > logEntry
    }
}

# Define a CRUD macro that generates multiple routes
# This is useful for generating boilerplate code
macro! crud(resource) {
    @ GET /${resource}
        > db.query("SELECT * FROM ${resource}")

    @ GET /${resource}/:id
        > db.query("SELECT * FROM ${resource} WHERE id = ?", id)

    @ POST /${resource}
        $ result = db.insert("${resource}", input)
        > { id: result.lastInsertId }

    @ DELETE /${resource}/:id
        > db.query("DELETE FROM ${resource} WHERE id = ?", id)
}

# Define a validation macro
macro! validate_required(field) {
    if field == null {
        > { error: "${field} is required", status: 400 }
    }
}

# Define a response wrapper macro
macro! json_response(data, status) {
    > {
        data: data,
        status: status,
        timestamp: now()
    }
}

# Define a middleware-like auth check macro
macro! require_auth(role) {
    if !auth {
        > { error: "Unauthorized", status: 401 }
    }
    if auth.role != role {
        > { error: "Forbidden", status: 403 }
    }
}

# Example usage of macros in a real API

# Use the CRUD macro to generate user endpoints
crud!(users)

# Use the CRUD macro to generate post endpoints
crud!(posts)

# Custom endpoint that uses other macros
@ GET /admin/stats
    + auth(jwt)
    require_auth!("admin")
    $ userCount = db.query("SELECT COUNT(*) FROM users")
    $ postCount = db.query("SELECT COUNT(*) FROM posts")
    json_response!({ users: userCount, posts: postCount }, 200)

# Endpoint with logging and validation
@ POST /feedback
    validate_required!(input.email)
    validate_required!(input.message)
    log!("INFO", "New feedback from " + input.email)
    $ result = db.insert("feedback", input)
    json_response!({ success: true, id: result.lastInsertId }, 201)
